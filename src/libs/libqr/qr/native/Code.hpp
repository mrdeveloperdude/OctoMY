#ifndef CODE_HPP
#define CODE_HPP

#include <QString>
#include <QImage>

#include "BitPattern.hpp"
#include "ErrorCorrection.hpp"
#include "qr/IQrGenerator.hpp"

class Encoder;
/**
 * @brief The Code class encapsulates a complete Qr code after encoding.
 * It is generated by an instance of Encoder.
 * 
 */
class Code: IQrCode
{
private:
	QString mErrorString;
	BitPattern mBitmap;
	BitPattern mFunctionmap;
	const int version;
	const Ecc &errorCorrectionLevel;
	int mask;
	
	// This should ONLY be called by Encoder.
private:
	Code(const Ecc &ecl, int version, int mask, const QByteArray &dataCodewords);
public:
	virtual ~Code(){};

private:
	bool fail(const QString &reason);
	int handleConstructorMasking(int mask);
	bool drawCodewords(const QByteArray &data);
	QByteArray appendErrorCorrection(const QByteArray &data);
	
private:
	void setFunctionModule(int x, int y, bool value);
	bool drawFunctionPatterns();
	bool drawFormatBits(int mask);
	bool drawVersion();
	bool drawFinderPattern(int x, int y);
	bool drawAlignmentPattern(int x, int y);
	
	
private:
	inline bool applyMask(int mask);
	inline void mask0();
	inline void mask1();
	inline void mask2();
	inline void mask3();
	inline void mask4();
	inline void mask5();
	inline void mask6();
	inline void mask7();
	
public:
	QString errorString() const;
	
	QString toSVG() const;
	QImage toImage() const;
	
	friend class Encoder;

	// IQrCode interface
public:
	quint8 width() const override;
	bool module(quint8 x, quint8 y) const override;

};



bool Code::applyMask(int mask) {
	switch (mask) {
		case 0: mask0(); break;
		case 1: mask1(); break;
		case 2: mask2(); break;
		case 3: mask3(); break;
		case 4: mask4(); break;
		case 5: mask5(); break;
		case 6: mask6(); break;
		case 7: mask7(); break;
		default: return fail("Unknown mask");
	}
	return true;
}

void Code::mask0() {
	const auto size = mBitmap.width();
	for (int y = 0; y < size; y++) {
		for (int x = 0; x < size; x++) {
			bool invert = (x + y) % 2 == 0;
			mBitmap.setPixel(x, y, mBitmap.getPixel(x, y) ^ (invert & !mFunctionmap.getPixel(x, y)));
		}
	}
}

void Code::mask1() {
	const auto size = mBitmap.width();
	for (int y = 0; y < size; y++) {
		for (int x = 0; x < size; x++) {
			bool invert = y % 2 == 0;
			mBitmap.setPixel(x, y, mBitmap.getPixel(x, y) ^ (invert & !mFunctionmap.getPixel(x, y)));
		}
	}
}

void Code::mask2() {
	const auto size = mBitmap.width();
	for (int y = 0; y < size; y++) {
		for (int x = 0; x < size; x++) {
			bool invert = x % 3 == 0;
			mBitmap.setPixel(x, y, mBitmap.getPixel(x, y) ^ (invert & !mFunctionmap.getPixel(x, y)));
		}
	}
}

void Code::mask3() {
	const auto size = mBitmap.width();
	for (int y = 0; y < size; y++) {
		for (int x = 0; x < size; x++) {
			bool invert = (x + y) % 3 == 0;
			mBitmap.setPixel(x, y, mBitmap.getPixel(x, y) ^ (invert & !mFunctionmap.getPixel(x, y)));
		}
	}
}

void Code::mask4() {
	const auto size = mBitmap.width();
	for (int y = 0; y < size; y++) {
		for (int x = 0; x < size; x++) {
			bool invert = (x / 3 + y / 2) % 2 == 0;
			mBitmap.setPixel(x, y, mBitmap.getPixel(x, y) ^ (invert & !mFunctionmap.getPixel(x, y)));
		}
	}
}

void Code::mask5() {
	const auto size = mBitmap.width();
	for (int y = 0; y < size; y++) {
		for (int x = 0; x < size; x++) {
			bool invert = x * y % 2 + x * y % 3 == 0;
			mBitmap.setPixel(x, y, mBitmap.getPixel(x, y) ^ (invert & !mFunctionmap.getPixel(x, y)));
		}
	}
}

void Code::mask6() {
	const auto size = mBitmap.width();
	for (int y = 0; y < size; y++) {
		for (int x = 0; x < size; x++) {
			bool invert = (x * y % 2 + x * y % 3) % 2 == 0;
			mBitmap.setPixel(x, y, mBitmap.getPixel(x, y) ^ (invert & !mFunctionmap.getPixel(x, y)));
		}
	}
}

void Code::mask7() {
	const auto size = mBitmap.width();
	for (int y = 0; y < size; y++) {
		for (int x = 0; x < size; x++) {
			bool invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
			mBitmap.setPixel(x, y, mBitmap.getPixel(x, y) ^ (invert & !mFunctionmap.getPixel(x, y)));
		}
	}
}







#endif // CODE_HPP
