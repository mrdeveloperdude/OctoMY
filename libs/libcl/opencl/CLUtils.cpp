#include <inttypes.h>
#include <limits>


#include "CLUtils.hpp"


#include "../libutil/utility/Utility.hpp"

#include <QMap>
#include <QString>
#include <QDebug>
#include <string.h>


QString OCLLocalMemoryTypeString(cl_device_local_mem_type type)
{

#define CL_LOCAL_MEMORY_TYPE_CASE(A) case(A):{ return #A; }break;
	switch(type) {
		CL_LOCAL_MEMORY_TYPE_CASE(CL_LOCAL);
		CL_LOCAL_MEMORY_TYPE_CASE(CL_GLOBAL);
	default: {
		return "Unknwon local memory type "+QString::number(type);
	}
	break;
	}
#undef CL_LOCAL_MEMORY_TYPE_CASE
}

QString OCLDeviceTypeString(cl_device_type type)
{
#define CL_DEVICE_TYPE_CASE(A, B) case(A):{ return B; }break
	switch(type) {
		CL_DEVICE_TYPE_CASE(CL_DEVICE_TYPE_DEFAULT, "DEFAULT");
		CL_DEVICE_TYPE_CASE(CL_DEVICE_TYPE_CPU, "CPU");
		CL_DEVICE_TYPE_CASE(CL_DEVICE_TYPE_GPU, "GPU");
		CL_DEVICE_TYPE_CASE(CL_DEVICE_TYPE_ACCELERATOR, "ACCELERATOR");
		CL_DEVICE_TYPE_CASE(CL_DEVICE_TYPE_CUSTOM, "CUSTOM");
		CL_DEVICE_TYPE_CASE(CL_DEVICE_TYPE_ALL, "ALL");
	default: {
		return "Unknwon device type string "+QString::number(type);
	}
	break;
	}
#undef CL_DEVICE_TYPE_CASE
}

QString OCLErrorString(cl_int code)
{
#define CL_ERROR_CODE_CASE(A) case(A):{ return #A; }break;
	switch(code) {
		CL_ERROR_CODE_CASE(CL_SUCCESS);
		CL_ERROR_CODE_CASE(CL_DEVICE_NOT_FOUND);
		CL_ERROR_CODE_CASE(CL_DEVICE_NOT_AVAILABLE);
		CL_ERROR_CODE_CASE(CL_COMPILER_NOT_AVAILABLE);
		CL_ERROR_CODE_CASE(CL_MEM_OBJECT_ALLOCATION_FAILURE);
		CL_ERROR_CODE_CASE(CL_OUT_OF_RESOURCES);
		CL_ERROR_CODE_CASE(CL_OUT_OF_HOST_MEMORY);
		CL_ERROR_CODE_CASE(CL_PROFILING_INFO_NOT_AVAILABLE);
		CL_ERROR_CODE_CASE(CL_MEM_COPY_OVERLAP);
		CL_ERROR_CODE_CASE(CL_IMAGE_FORMAT_MISMATCH);
		CL_ERROR_CODE_CASE(CL_IMAGE_FORMAT_NOT_SUPPORTED);
		CL_ERROR_CODE_CASE(CL_BUILD_PROGRAM_FAILURE);
		CL_ERROR_CODE_CASE(CL_MAP_FAILURE);

#ifdef CL_VERSION_1_1
		CL_ERROR_CODE_CASE(CL_MISALIGNED_SUB_BUFFER_OFFSET);
		CL_ERROR_CODE_CASE(CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST);
#endif

		CL_ERROR_CODE_CASE(CL_COMPILE_PROGRAM_FAILURE);
		CL_ERROR_CODE_CASE(CL_LINKER_NOT_AVAILABLE);
		CL_ERROR_CODE_CASE(CL_LINK_PROGRAM_FAILURE);
		CL_ERROR_CODE_CASE(CL_DEVICE_PARTITION_FAILED);
		CL_ERROR_CODE_CASE(CL_KERNEL_ARG_INFO_NOT_AVAILABLE);
		CL_ERROR_CODE_CASE(CL_INVALID_VALUE);
		CL_ERROR_CODE_CASE(CL_INVALID_DEVICE_TYPE);
		CL_ERROR_CODE_CASE(CL_INVALID_PLATFORM);
		CL_ERROR_CODE_CASE(CL_INVALID_DEVICE);
		CL_ERROR_CODE_CASE(CL_INVALID_CONTEXT);
		CL_ERROR_CODE_CASE(CL_INVALID_QUEUE_PROPERTIES);
		CL_ERROR_CODE_CASE(CL_INVALID_COMMAND_QUEUE);
		CL_ERROR_CODE_CASE(CL_INVALID_HOST_PTR);
		CL_ERROR_CODE_CASE(CL_INVALID_MEM_OBJECT);
		CL_ERROR_CODE_CASE(CL_INVALID_IMAGE_FORMAT_DESCRIPTOR);
		CL_ERROR_CODE_CASE(CL_INVALID_IMAGE_SIZE);
		CL_ERROR_CODE_CASE(CL_INVALID_SAMPLER);
		CL_ERROR_CODE_CASE(CL_INVALID_BINARY);
		CL_ERROR_CODE_CASE(CL_INVALID_BUILD_OPTIONS);
		CL_ERROR_CODE_CASE(CL_INVALID_PROGRAM);
		CL_ERROR_CODE_CASE(CL_INVALID_PROGRAM_EXECUTABLE);
		CL_ERROR_CODE_CASE(CL_INVALID_KERNEL_NAME);
		CL_ERROR_CODE_CASE(CL_INVALID_KERNEL_DEFINITION);
		CL_ERROR_CODE_CASE(CL_INVALID_KERNEL);
		CL_ERROR_CODE_CASE(CL_INVALID_ARG_INDEX);
		CL_ERROR_CODE_CASE(CL_INVALID_ARG_VALUE);
		CL_ERROR_CODE_CASE(CL_INVALID_ARG_SIZE);
		CL_ERROR_CODE_CASE(CL_INVALID_KERNEL_ARGS);
		CL_ERROR_CODE_CASE(CL_INVALID_WORK_DIMENSION);
		CL_ERROR_CODE_CASE(CL_INVALID_WORK_GROUP_SIZE);
		CL_ERROR_CODE_CASE(CL_INVALID_WORK_ITEM_SIZE);
		CL_ERROR_CODE_CASE(CL_INVALID_GLOBAL_OFFSET);
		CL_ERROR_CODE_CASE(CL_INVALID_EVENT_WAIT_LIST);
		CL_ERROR_CODE_CASE(CL_INVALID_EVENT);
		CL_ERROR_CODE_CASE(CL_INVALID_OPERATION);
		CL_ERROR_CODE_CASE(CL_INVALID_GL_OBJECT);
		CL_ERROR_CODE_CASE(CL_INVALID_BUFFER_SIZE);
		CL_ERROR_CODE_CASE(CL_INVALID_MIP_LEVEL);
		CL_ERROR_CODE_CASE(CL_INVALID_GLOBAL_WORK_SIZE);
		CL_ERROR_CODE_CASE(CL_INVALID_PROPERTY);
		CL_ERROR_CODE_CASE(CL_INVALID_IMAGE_DESCRIPTOR);
		CL_ERROR_CODE_CASE(CL_INVALID_COMPILER_OPTIONS);
		CL_ERROR_CODE_CASE(CL_INVALID_LINKER_OPTIONS);
		CL_ERROR_CODE_CASE(CL_INVALID_DEVICE_PARTITION_COUNT);
		CL_ERROR_CODE_CASE(CL_INVALID_PIPE_SIZE);
		CL_ERROR_CODE_CASE(CL_INVALID_DEVICE_QUEUE);

		// extension errors
		CL_ERROR_CODE_CASE(CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR);
		CL_ERROR_CODE_CASE(CL_PLATFORM_NOT_FOUND_KHR);
//		CL_ERROR_CODE_CASE(CL_INVALID_D3D10_DEVICE_KHR);
//		CL_ERROR_CODE_CASE(CL_INVALID_D3D10_RESOURCE_KHR);
//		CL_ERROR_CODE_CASE(CL_D3D10_RESOURCE_ALREADY_ACQUIRED_KHR);
//		CL_ERROR_CODE_CASE(CL_D3D10_RESOURCE_NOT_ACQUIRED_KHR);

	default: {
		return "Unknwon errorcode "+QString::number(code);
	}
	break;
	}
#undef CL_ERROR_CODE_CASE
}


void failOnCLError(cl_int code, QString msg, QString file, int line)
{
	if(CL_SUCCESS==code) {
		return;
	}
	QString error=OCLErrorString(code);
	qWarning()<<"CL ERROR: "<<error<<"("<<code<<") for "<<msg<<" @"<<file<<":"<<line;
	exit(1);
}




QString CLDeviceToString(cl::Device &dev)
{

	std::string sname=dev.getInfo<CL_DEVICE_NAME>();
	QString name=QString::fromLocal8Bit(sname.c_str());
	return name //Device name
		   + " ( "+OCLDeviceTypeString(dev.getInfo<CL_DEVICE_TYPE>()) +" x " //Type
		   + QString::number(dev.getInfo<CL_DEVICE_MAX_COMPUTE_UNITS>())+" ) Memory: " // Number of cores
		   + utility::humanReadableSize(dev.getInfo<CL_DEVICE_GLOBAL_MEM_SIZE>(), 2) + " Global, "
		   + utility::humanReadableSize(dev.getInfo<CL_DEVICE_LOCAL_MEM_SIZE>(), 2) + (CL_GLOBAL==dev.getInfo<CL_DEVICE_LOCAL_MEM_TYPE>()?" Global, ":" Local, ")
		   + utility::humanReadableSize(dev.getInfo<CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE>(), 2) +" Constant";
}



QDebug &operator<<(QDebug &d, cl::Device &dev)
{
	QString s=CLDeviceToString(dev);
	d.noquote().operator<<(s);
	return d;
}
