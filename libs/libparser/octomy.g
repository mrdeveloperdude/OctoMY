-- NOTE: Why don't we simplify the build by using merged_output option to form
--       one file instead of 4? Because this file becomes impossible to use,
--       since we cannot include it without causing duplicate symbols being
--       linked and we cannot link it without manually specifying a header for
--       it.

-- This gives a name to the table. Default is simply "parser"
-- Generates octomy_table.cpp & octomy_table_p.h
%parser octomy_table

-- This gives filenames to the parser itself
%decl octomy_parser.hpp

%impl octomy_parser.cpp

%token TOK_NUMBER
%token TOK_DESCRIPTOR
%token TOK_PLAN
%token TOK_PUPPET
%token TOK_HUB
%token TOK_REMOTE
%token TOK_AGENT
%token TOK_MEMBER
%token TOK_PUBKEY
%token TOK_KEY
%token TOK_PLUGIN
%token TOK_TRUE
%token TOK_FALSE
%token TOK_LPAREN
%token TOK_RPAREN
%token TOK_LBRACKET
%token TOK_RBRACKET
%token TOK_LBRACE
%token TOK_RBRACE
%token TOK_COLON
%token TOK_ASSIGN
%token TOK_STRING
%token TOK_IMPORT
%token TOK_IDENTIFIER
%start Plan

/:// WARNING:                                                             :WARNING
// WARNING: DO NOT EDIT THIS FILE! IT IS AUTOGENERATED BY QLALR         :WARNING
// WARNING:                                                             :WARNING

#ifndef OCTOMY_PARSER_HPP
#define OCTOMY_PARSER_HPP

#include "octomy_table_p.h"

#include <QString>
#include <QDebug>


struct yy_buffer_state;
typedef struct yy_buffer_state *YY_BUFFER_STATE;

class OctomyLexer{
	private:
		YY_BUFFER_STATE buf;
	public:

		bool init(const char *in);
		bool deinit();
		int nextToken();

};




class OctomyParser{
	private:

		inline int nextToken(){
			return lexer.nextToken();
		}

	private:

		OctomyLexer lexer;
		octomy_table table;

		union Value {
				int i;
				unsigned u;
				unsigned long ul;
				unsigned long long ull;
				long l;
				double d;
				float f;
				const QString *s;
		};

		inline void reallocateStack(){
			if (! stack_size)
				stack_size = 128;
			else
				stack_size <<= 1;

			sym_stack = reinterpret_cast<Value*> (realloc(sym_stack, stack_size * sizeof(Value)));
			state_stack = reinterpret_cast<int*> (realloc(state_stack, stack_size * sizeof(int)));
		}

		inline Value &sym(int index)
		{ return sym_stack [tos + index - 1]; }


		bool isTypename(const QString *s) const
		{
			return types.contains(s);
		}

		inline const QString *intern(const QString &s)
		{ return &*string_repository.insert(s); }


		int tos;
		int stack_size;
		Value *sym_stack;
		int *state_stack;
		Value yylval;
		QSet<QString> string_repository;
		QSet<const QString*> types;

		struct /*Context*/ {
				int line;
				const QString *function_name;
				QString fileName;

				void init()
				{
					line = 1;
					function_name = 0;
					fileName.clear();
				}
		} context;



	public:
		OctomyParser()
			: tos(0)
			, stack_size(0)
			, sym_stack(0)
			, state_stack(0)
		{
			qDebug()<<"PARSER CTOR";
		}

		~OctomyParser(){
			if (stack_size) {
				free(sym_stack);
				free(state_stack);
			}
		}


		bool parse(QString s){
			qDebug()<<"PARSER PARSE";
			bool status=lexer.init(s.toStdString().c_str());
			const int INITIAL_STATE = 0;
			int yytoken = -1;
			reallocateStack();
			context.init();
			tos = 0;
			state_stack[++tos] = INITIAL_STATE;
			while (true){
				if (yytoken == -1 && - table.TERMINAL_COUNT != table.action_index [state_stack [tos]]){
					yytoken = nextToken();
				}

				int act = table.t_action (state_stack [tos], yytoken);

				if (act == table.ACCEPT_STATE) {
					return true;
				}
				else if (act > 0) {
					if (++tos == stack_size){
						reallocateStack();
					}
					sym_stack [tos] = yylval;
					state_stack [tos] = act;
					yytoken = -1;
				}
				else if (act < 0) {
					int r = - act - 1;
					int ridx = table.rule_index [r];
					qDebug()<< "*** reduce using rule %d %s ::=" << (r + 1) << table.spell[table.rule_info [ridx]];
					++ridx;
					for (int i = ridx; i < ridx + table.rhs [r]; ++i) {
						int symbol = table.rule_info [i];
						if (const char *name = table.spell [symbol]){
							printf (" %s", name);
						}
						else{
							printf (" #%d", symbol);
						}
					}
					printf ("\n");

					tos -= table.rhs [r];
					act = state_stack [tos++];



					state_stack [tos] = table.nt_action (act, table.lhs [r] - table.TERMINAL_COUNT);
				}

				else
				{
					// ### ERROR RECOVERY HERE
					break;
				}
			}

			//fprintf (stderr, "%s:%d: Syntax Error\n", qPrintable(context.fileName), context.line);
			qWarning()<<"SYNTAX ERROR: "<< qPrintable(context.fileName) << ":"<< context.line <<"\n";

			return false;

			status &=lexer.deinit();
			return status;
		}

		QString toString(){
			QString out="";
			for (int r = 0; r < octomy_table::RULE_COUNT; ++r) {
				int ridx = octomy_table::rule_index [r];
				int rhs = octomy_table::rhs [r];
				out += QString::number(r + 1) +" "+ QString(octomy_table::spell[octomy_table::rule_info [ridx]])+":\n";
				++ridx;
				for (int i = ridx; i < ridx + rhs; ++i)
				{
					int symbol = octomy_table::rule_info [i];
					if (const char *name = octomy_table::spell [symbol]){
						out+="\tname="+QString(name);
					}
					else{
						out+="\tsymbol="+QString(symbol);
					}
					out+="\n";
				}
			}
			return out;
		}

		void consumeRule(int rule);

};


#endif // OCTOMY_PARSER_HPP
:/


/.// WARNING:                                                             :WARNING
// WARNING: DO NOT EDIT THIS FILE! IT IS AUTOGENERATED BY QLALR         :WARNING
// WARNING:                                                             :WARNING


#include "octomy_parser.hpp"
#include "octomy_lexer.h"

#include <QDebug>
#include <cstdlib>

////////////////////////////////////////////////////////////////////////////

bool OctomyLexer::init(const char *in){
	qDebug()<<"INITIALIZING LEXER";
	buf=yy_scan_string(in);
	return 0!=buf;
}

bool OctomyLexer::deinit(){
	qDebug()<<"DEINITIALIZING LEXER";
	buf=0;
	return true;
}

////////////////////////////////////////////////////////////////////////////

void OctomyParser::consumeRule(int ruleno){
	qDebug()<<"CONSUMING RULE: "<<ruleno;

	switch (ruleno) {
		./
		Plan::= TOK_PLAN TOK_LBRACE PlanParts TOK_RBRACE;
		/.
		case $rule_number:
			qDebug() << "Plan";
			break;
			./

			PlanParts::= PlanParts Agent;
			PlanParts::= PlanParts Hub;
			PlanParts::= PlanParts Remote;
			PlanParts::= ;


			Agent::= TOK_AGENT TOK_LBRACE AgentParts TOK_RBRACE;
			/.
		case $rule_number:
			qDebug() << "Agent";
			break;
			./


			AgentParts::= AgentParts Puppet;
			AgentParts::= ;

			Hub::= TOK_HUB TOK_LBRACE HubParts TOK_RBRACE;
			/.
		case $rule_number:
			qDebug() << "Hub";
			break;
			./


			HubParts::= ;

			Remote::= TOK_REMOTE TOK_LBRACE RemoteParts TOK_RBRACE;
			/.
		case $rule_number:
			qDebug() << "Remote";
			break;
			./

			RemoteParts::= ;


			Puppet::= TOK_PUPPET TOK_LBRACE PuppetParts TOK_RBRACE;
			/.
		case $rule_number:
			qDebug() << "Puppet";
			break;
			./

			PuppetParts::= PuppetParts Member;
			PuppetParts::= ;

			Member::= TOK_MEMBER TOK_LBRACE MemberParts TOK_RBRACE;
			/.
		case $rule_number:
			qDebug() << "Member";
			break;
			./


			MemberParts::= MemberParts Var;
			MemberParts::= ;

			Var::= TOK_IDENTIFIER TOK_ASSIGN TOK_STRING;
			Var::= TOK_IDENTIFIER TOK_ASSIGN TOK_NUMBER;
			Var::= TOK_IDENTIFIER TOK_ASSIGN Bool;

			/.
		case $rule_number:
			qDebug() << "Var";
			break;
			./


			Bool::= TOK_TRUE;
			Bool::= TOK_FALSE;

			/.
		case $rule_number:
			qDebug() << "Bool";
			break;
			./


			/.

	} // switch

}


./


