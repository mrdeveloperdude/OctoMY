--/*
-- NOTE: Faux comment are scattered liberally around this file so as to allow
--       us to edit it in QtCreator without wihtout feeling like pulling one's
--       hard earned grey hair out.
--
-- NOTE: Why don't we simplify the build by using merged_output option to form
--       one file instead of 4? Because this file becomes impossible to use,
--       since we cannot include it without causing duplicate symbols being
--       linked and we cannot link it without manually specifying a header for
--       it.


-- This gives a name to the table. Default is simply "parser"
-- Generates octomy_table.cpp & octomy_table_p.h
%parser octomy_table


-- This gives filename to the header for the parser itself
%decl octomy_parser.hpp

-- This gives filename to the source for the parser itself
%impl octomy_parser.cpp

-- This lists all the tokens with a string name as expected input from flex
-- NOTE: The prepended '%' in the names of tokens simply allows us to easily
--       spot "tokens" in the debugging info, and as such exists purely for
--       the developer's convenience.

%token TOK_TRANSLATION_UNIT "%translation_unit"

%token TOK_SPEC 		 	"%spec"

%token TOK_PLAN 		 	"%plan"

%token TOK_SENSOR	 		"%sensor"
%token TOK_CAMERA	 		"%camera"
%token TOK_SERIAL	 		"%serial"
%token TOK_BLUETOOTH	 	"%bluetooth"
%token TOK_NFC	 			"%nfc"

%token TOK_CONTROLLER	 	"%controller"

%token TOK_HUB 		 		"%hub"
%token TOK_REMOTE 		 	"%remote"
%token TOK_AGENT 		 	"%agent"
%token TOK_MEMBER 		 	"%member"
%token TOK_PUPPET 		 	"%puppet"

%token TOK_PUBKEY 		 	"%pubkey"
%token TOK_KEY 		 		"%key"

%token TOK_PLUGIN 		 	"%plugin"
%token TOK_IMPORT 		 	"%import"

%token TOK_DESCRIPTOR 		"%descriptor"

%token TOK_LPAREN 		 	"%lparen"
%token TOK_RPAREN 		 	"%rparen"
%token TOK_LBRACKET 		"%lbracket"
%token TOK_RBRACKET 		"%lbracket"
%token TOK_LBRACE 		 	"%lbrace"
%token TOK_RBRACE 		 	"%rbrace"
%token TOK_COLON 		 	"%colon"
%token TOK_SEMICOLON	 	"%semicolon"
%token TOK_ASSIGN 		 	"%assign"

%token TOK_INTCONSTANT		"%integer constant"
%token TOK_FLOATCONSTANT	"%float constant"
%token TOK_STRINGCONSTANT	"%string constant"
%token TOK_BOOLCONSTANT		"%bool constant"

%token TOK_IDENTIFIER		"%identifier"
%token TOK_TYPE_NAME 		"%type_name"

-- This gives the "root" rule that is expected as first in input.
%start TranslationStream

/:// WARNING:                                                             :WARNING
// WARNING: DO NOT EDIT THIS FILE! IT IS AUTOGENERATED BY QLALR         :WARNING
// WARNING: CHANGES WILL BE OVERWRITTEN                                 :WARNING
// WARNING:                                                             :WARNING
// Faux comment. See above. */
#ifndef OCTOMY_PARSER_HPP
#define OCTOMY_PARSER_HPP

#include "octomy_table_p.h"

#include "../../libs/libparser/Context.hpp"
#include "../../libs/libparser/ParseTreeNode.hpp"
#include "../../libs/libparser/ParseError.hpp"
#include "../../libs/libcore/utility/Utility.hpp"

#include <QString>
#include <QDebug>
#include <QPair>


// NOTE: We could invent our own clever union as is customary to keep the
//       literal values during parsing. Luckily Qt has the mother of all variant
//       implementations that does exactly what we want and more:

typedef QVariant Value;

// NOTE: These are required to allow us to feed lexer with data from a string
//       (as opposed to from a file which is customary):

struct yy_buffer_state;
typedef struct yy_buffer_state *YY_BUFFER_STATE;

// The lexer wrapper. The source for "nextToken()" is generated by flex based on
// the content of the flex source file "octomy.l".

class OctomyLexer{
	private:
		YY_BUFFER_STATE buf;

		QSet<const QString> types;
	public:
		Value yylval;
		Context context;

		OctomyLexer()
			: buf(0)
			, yylval(0)
		{
		}

	public:
		bool isTypename(const QString s) const
		{
			return types.contains(s);
		}

		bool init(const char *in);
		bool deinit();
		int nextToken();
};


// The parser class. This is the part of the parser that what we actually expose
// and use from the rest of the code, especially the "parse()" method.

class OctomyParser{
	private:
		inline int nextToken(){
			return lexer.nextToken();
		}

	private:

		struct StackNode{
			public:
				int state;
				Value value;
				Context context;
			public:
				StackNode(int s=0, Value v=Value(), Context c=Context())
					: state(s)
					, value(v)
					, context(c)
				{

				}
		};

	private:

		//Wrapper for our lexer generated by flex. We will use the nextToken()
		//method to get next token from input stream
		OctomyLexer lexer;

		//The parsing table autogenerated by qlalr. This is where the data
		//needed to sue the statemachine is kept.
		octomy_table table;

		//Complete log kept during parsing. Useful for debugging
		QString lastParseLog;

		//All errors collected along the way during parsing. The parse was
		//successfull only when this is empty.
		QVector<ParseError> errors;

		//Current stack level
		int tos;

		//Max stack level. Used when printing stack when debugging to avoid
		// all the zeros at the end.
		int max_tos;

		//The parse stack. This is used during parsing in parse() method to
		//keep the current state while completing rules.
		QVector<StackNode> stack;

		//String table usable via the string() method. Not currently in use
		QSet<QString> strings;

		// Parse tree. this structure is the real result of the parse, and will
		// beprocessed further after parsing is done to create the actual
		// usefull data in the program (the OctoMYâ„¢ Plan).
		ParseTreeNode *rootNode;
		ParseTreeNode *currentNode;
		QVector<ParseTreeNode *> trees;

	private:

		//Manage stack memory
		void reallocateStack()
		{
			int sz=stack.size();
			if (sz<128){
				sz = 128;
			}
			else{
				sz <<= 1;
			}
			stack.resize(sz);
		}

		//Gives easy access to values on the parse stack
		Value &symbol(int index)
		{
			return stack [tos + index -2].value;
		}

		//Gives easy access to the string table
		const QString *string(const QString &s)
		{
			return &*strings.insert(s);
		}
		void registerVariable(QString identifier, QVariant value)
		{
			if(0==currentNode){
				addError("ERROR: Trying to register var on 0 node");
				return;
			}
			if(currentNode->hasVariable(identifier)){
				addError("ERROR: Trying to add duplicate variable");
				return;
			}
			qDebug()<<"Adding var: "<<identifier<<"="<<value;
			currentNode->addVariable(identifier,value);
		}

		void addError(QString message, QString hint="")
		{
			ParseError error(lexer.context,message, hint);
			qWarning()<<"ERROR: "<<error.toString();
			errors.append(error);
		}

		void pushNode(QString name)
		{
			qDebug()<<"PUSH "<<name;
			ParseTreeNode *ptn=new ParseTreeNode(name);
			if(0!=ptn){
				if(0==currentNode){
					currentNode=rootNode=ptn;
				}
				else{
					currentNode->addChild(ptn);
					currentNode=ptn;
				}
			}
		}

		void popNode()
		{
			qDebug()<<"POP";
			if(0==currentNode){
				addError("ERROR: Trying to pop 0 node");
				return;
			}
			ParseTreeNode *completeTree=currentNode;
			currentNode=currentNode->parent();
			// We now have a complete tree
			if(0==currentNode){
				qDebug()<<"Adding tree to forrest: "<<completeTree->name();
				trees.append(completeTree);
			}
		}

	public:
		OctomyParser()
			: tos(0)
			, max_tos(0)
			, rootNode(0)
			, currentNode(0)
		{
			qDebug()<<"PARSER CTOR";
		}

		~OctomyParser(){
		}

		bool parse(QString s)
		{
			QVector<QPair<QString, QString> > list;
			list.append( QPair<QString, QString> ("default", s) );
			return parse(list);
		}

		bool parse(QVector<QPair<QString, QString> > st)
		{
			qDebug()<<"PARSE";
			QString s="";
			for(QVector<QPair<QString, QString> >::iterator i=st.begin(),e=st.end(); i != e; ++i){
				QPair<QString, QString> &pair=*i;
				QString key=pair.first;
				QString val=pair.second;
				s+="translation_unit: \""+key+"\";\n";
				s+=val;
			}
			utility::stringToFile("translation_unit.txt",s);
			if(!lexer.init(s.toStdString().c_str())){
				qWarning()<<"ERROR: Could not initialize lexer";
				return false;
			}
			lastParseLog="";
			if(0!=rootNode){
				rootNode->clear();
				rootNode=0;
			}
			currentNode=0;
			const int INITIAL_STATE = 0;
			int yytoken = -1;
			reallocateStack();
			lexer.context=Context();
			tos = 0;
			max_tos=0;
			stack[++tos].state=INITIAL_STATE;
			bool ok=false;
			while (true){
				if (yytoken == -1 && - table.TERMINAL_COUNT != table.action_index [stack [tos].state]){
					yytoken = nextToken();
				}
				int act = table.t_action (stack [tos].state, yytoken);
				// 1. act = table.ACCEPT_STATE means we are done with a successfull parse
				if (act == table.ACCEPT_STATE) {
					ok=true;
					break;
				}
				// 2. act > 0 means we need a new token
				else if (act > 0) {
					if (++tos == stack.size()){
						reallocateStack();
					}
					Value v=lexer.yylval;
					qDebug()<<"INSERTING "<<v<<" into stack @"<<tos;
					stack[tos]=StackNode(act, v);
					yytoken = -1;
				}
				// 3. act < 0 means we have a full production and its time to handle it
				else if (act < 0) {
					int r = - act - 1;
					int ridx = table.rule_index [r];
					consumeRule(r);
					QString ruleName=QString( table.spell[table.rule_info [ridx]]);
					lastParseLog+=ruleName+" ("+QString::number(r + 1)+"):\n";
					++ridx;
					for (int i = ridx; i < ridx + table.rhs [r]; ++i) {
						int symbol = table.rule_info [i];
						if (const char *name = table.spell [symbol]){
							lastParseLog+=" + "+QString(name)+"\n";
						}
						else{
							lastParseLog+=" + "+QString::number(symbol)+"\n";
						}
					}
					lastParseLog+="\n";
					if(tos>max_tos){
						max_tos=tos;
					}
					tos -= table.rhs [r];
					act = stack [tos++].state;
					stack [tos].state = table.nt_action (act, table.lhs [r] - table.TERMINAL_COUNT);
				}
				// 4. act = 0 means an error was detected that we should try to handle
				else{
					ok=false;
					break;
				}
			}
			if(!ok){
				qDebug()<<"SAD ENDING";
				int ers = stack [tos].state;
				int shifts = 0;
				int reduces = 0;
				const int NUM_EXPECT=10;
				int expected_tokens[NUM_EXPECT]={0};
				for (int tk = 0; tk < table.TERMINAL_COUNT; ++tk) {
					int k = table.t_action(ers, tk);
					if (! k){
						continue;
					}
					else if (k < 0){
						++reduces;
					}
					else if (table.spell[tk]) {
						if (shifts < NUM_EXPECT){
							expected_tokens[shifts] = tk;
						}
						++shifts;
					}
				}
				int num=NUM_EXPECT;
				if(num>shifts){
					num=shifts;
				}
				QString err="";
				err+=QStringLiteral("SYNTAX ERROR ON LINE ")+QString::number(lexer.context.line())+" At TOKEN "+QString::number(lexer.context.token())+"\n";
				err+=" FOUND "+QString(table.spell[yytoken])+" = "+lexer.yylval.toString()+" (code="+QString::number(yytoken)+")\n";
				if(num>0){
					if(1==num){
						err+=" EXPECTED "+QString(table.spell[expected_tokens[0]])+".\n";
					}
					else{
						err+=" EXPECTED ONE OF THE FOLLOWING:\n";
						for(int i=0;i<num;++i){
							err+=QStringLiteral(" + ")+QString(table.spell[expected_tokens[i]])+"\n";
						}
					}
				}
				addError(err);
				lastParseLog+=err;
			}
			else{
				qDebug()<<"HAPPY ENDING";
			}
			if(!lexer.deinit()){
				qWarning()<<"ERROR: Could not de-initialize lexer";
			}
			return ok;
		}


		QString parseLog(){
			return lastParseLog;
		}


		QString grammarToString(){
			QString out="";
			out+="       octomy_table::RULE_COUNT="+QString::number(octomy_table::RULE_COUNT)+"\n";
			for (int r = 0; r < octomy_table::RULE_COUNT; ++r) {
				int ridx = octomy_table::rule_index [r];
				int rhs = octomy_table::rhs [r];
				int ri = octomy_table::rule_info [ridx];
				const  char  *sp=octomy_table::spell[ri];
				out+="ridx = octomy_table::rule_index ["+QString::number(r)+"]="+QString::number(ridx)+"\n";
				out+="ri   = octomy_table::rule_info ["+QString::number(r)+"]="+QString::number(ri)+"\n";
				out+="rhs  = octomy_table::rhs ["+QString::number(r)+"]="+QString::number(rhs)+"\n";
				out+="sp   = octomy_table::spell["+QString::number(ri)+"]="+QString(sp)+"\n";
				++ridx;
				for (int i = ridx; i < ridx + rhs; ++i){
					int symbol = octomy_table::rule_info [i];
					const char *name = octomy_table::spell [symbol];
					if (name){
						out+="          + name="+QString(name);
					}
					else{
						out+="          + symbol="+QString::number(symbol);
					}
					out+="\n";
				}
			}
			return out;
		}

		QString treesToString(){
			QString out="";
			for(QVector<ParseTreeNode *>::iterator i=trees.begin(), e=trees.end();i!=e;++i){
				out+=(*i)->toString();
			}
			return out;
		}

		QString stackToString(){
			QString out;
			int num=stack.size();
			if(num>max_tos){
				num=max_tos;
			}
			out+=QStringLiteral("stack size: ")+QString::number(num);
			int i=0;
			for(QVector<StackNode>::iterator b=stack.begin(), e=stack.end();b!=e;++b){
				out+=" + "+QString::number(i)+"= "+stack[i].value.toString()+" ("+QString::number(stack[i].state)+")\n";
				i++;
				if(max_tos==i){
					break;
				}
			}
			return out;

		}

		QVector<ParseError> getErrors()
		{
			return errors;
		}

		QString getErrorText()
		{
			QString out="";
			for(QVector<ParseError>::iterator i=errors.begin(), e=errors.end();e!=i;++i){
				out+=(*i).toString()+"\n";
			}
			return out;
		}

		QVector<ParseTreeNode *> getTrees()
		{
			return trees;
		}

		void debugRule(QString msg,int ruleno){
			qDebug()<<"DEBUG "<<msg<<" ("<<ruleno<<"): -2="<<symbol(-2)<<", -1"<<symbol(-1)<<", 0="<<symbol(0)<<", 1="<<symbol(1)<<", 2="<<symbol(2)<<".";
		}

		void consumeRule(int rule);

};


#endif // OCTOMY_PARSER_HPP
//:/

/.
// WARNING:                                                             :WARNING
// WARNING: DO NOT EDIT THIS FILE! IT IS AUTOGENERATED BY QLALR         :WARNING
// WARNING:                                                             :WARNING


#include "octomy_parser.hpp"
#include "octomy_lexer.h"

#include <QDebug>
#include <cstdlib>

////////////////////////////////////////////////////////////////////////////

bool OctomyLexer::init(const char *in){
	qDebug()<<"INITIALIZING LEXER";
	buf=yy_scan_string(in);
	return 0!=buf;
}

bool OctomyLexer::deinit(){
	qDebug()<<"DEINITIALIZING LEXER";
	buf=0;
	return true;
}

////////////////////////////////////////////////////////////////////////////


void OctomyParser::consumeRule(int ruleno){
	qDebug()<<"CONSUMING RULE: "<<ruleno;
	switch (ruleno) {

// NOTE: The input may never hold more than one Plan across all translation
//       units, and said plan must always come last.

/*./

		TranslationStream ::= TranslationUnitPlan;
		TranslationStream ::= TranslationUnitSpecPlan;
		TranslationStream ::= TranslationStreamNonPlan TranslationUnitPlan;
		TranslationStream ::= TranslationStreamNonPlan TranslationUnitSpecPlan;

		TranslationStreamNonPlan ::= TranslationStreamNonPlan TranslationUnitSpec;
		TranslationStreamNonPlan ::= TranslationStreamNonPlan TranslationUnitEmpty;
		TranslationStreamNonPlan ::= TranslationUnitSpec;

		TranslationUnitEmpty ::= TranslationUnitMarker;
		TranslationUnitSpec ::= TranslationUnitMarker OneOrMoreSpecs;
		TranslationUnitPlan ::= TranslationUnitMarker Plan;
		TranslationUnitSpecPlan ::= TranslationUnitMarker OneOrMoreSpecs Plan;

		TranslationUnitMarker::= TOK_TRANSLATION_UNIT TOK_COLON TOK_STRINGCONSTANT OptionalSemicolon;
		OneOrMoreSpecs ::= OneOrMoreSpecs Spec;
		OneOrMoreSpecs ::= Spec;

/.*/
		case $rule_number:{
			//debugRule("TU",ruleno);
			lexer.context.setTranslationUnit(symbol(0).toString());
		}break;
/*./
		SpecStart::= TOK_SPEC;
/.*/
		case $rule_number:{
			pushNode("spec");
		}break;
/*./
		Spec::= SpecStart TOK_LBRACE SpecParts TOK_RBRACE OptionalSemicolon;
/.*/
		case $rule_number:{
			// debugRule("SPEC",ruleno);
			popNode();
		}break;
/*./
		SpecParts::= SpecParts Controller;
		SpecParts::= SpecParts Sensor;
		SpecParts::= SpecParts Puppet;
		SpecParts::= SpecParts Var;
		SpecParts::= ;

		PlanStart::= TOK_PLAN;
/.*/
		case $rule_number:{
			pushNode("plan");
		}break;


/*./
		Plan::= PlanStart TOK_LBRACE PlanParts TOK_RBRACE OptionalSemicolon;
/.*/
		case $rule_number:{
			// debugRule("PLAN",ruleno);
			popNode();
		}break;


/*./
		PlanParts::= PlanParts Agent;
		PlanParts::= PlanParts Hub;
		PlanParts::= PlanParts Remote;
		PlanParts::= PlanParts Var;
		PlanParts::= ;


		ControllerStart::= TOK_Controller;
/.*/
		case $rule_number:{
			pushNode("controller");
		}break;


/*./
		Controller::= ControllerStart TOK_LBRACE ControllerParts TOK_RBRACE OptionalSemicolon;
/.*/
		case $rule_number:{
			popNode();
		}break;


/*./

		ControllerParts::= ControllerParts Var;
		ControllerParts::= ;


		AgentStart::= TOK_AGENT ;
/.*/
		case $rule_number:{
			pushNode("agent");
		}break;


/*./
		Agent::= AgentStart TOK_LBRACE AgentParts TOK_RBRACE OptionalSemicolon;
/.*/
		case $rule_number:{
			popNode();
		}break;


/*./
		AgentParts::= AgentParts Puppet;
		AgentParts::= AgentParts Descriptor;
		AgentParts::= AgentParts Var;
		AgentParts::= ;

		HubStart::= TOK_HUB ;
/.*/
		case $rule_number:{
			pushNode("hub");
		}break;


/*./
		Hub::= HubStart  TOK_LBRACE HubParts TOK_RBRACE OptionalSemicolon;
/.*/
		case $rule_number:{
			popNode();
		}break;


/*./
		HubParts::= HubParts Var;
		HubParts::= ;

		RemoteStart::= TOK_REMOTE ;
/.*/
		case $rule_number:{
			pushNode("remote");
		}break;


/*./
		Remote::= RemoteStart TOK_LBRACE RemoteParts TOK_RBRACE OptionalSemicolon;
/.*/
		case $rule_number:{
			popNode();
		}break;


/*./
		RemoteParts::= RemoteParts Var;
		RemoteParts::= ;


		DescriptorStart::= TOK_SENSOR;
		DescriptorStart::= TOK_CAMERA;
		DescriptorStart::= TOK_SERIAL;
		DescriptorStart::= TOK_BLUETOOTH;
		DescriptorStart::= TOK_NFC;
/.*/
		case $rule_number:{
			pushNode("descriptor");
			registerVariable("ARNE", symbol($rule_number));
			registerVariable("BJARNE", symbol(0));
			registerVariable("ALISE", symbol(1));
		}break;


/*./
		Descriptor::= DescriptorStart TOK_LBRACE DescriptorParts TOK_RBRACE OptionalSemicolon;
/.*/
		case $rule_number:{
			popNode();
		}break;


/*./
		DescriptorParts::= DescriptorParts Var;
		DescriptorParts::= ;


		PuppetStart::= TOK_PUPPET ;
/.*/
		case $rule_number:{
			pushNode("puppet");
		}break;


/*./
		Puppet::= PuppetStart TOK_LBRACE PuppetParts TOK_RBRACE OptionalSemicolon;
/.*/
		case $rule_number:{
			popNode();
		}break;


/*./
		PuppetParts::= PuppetParts Var;
		PuppetParts::= PuppetParts Member;
		PuppetParts::= PuppetParts Controller;
		PuppetParts::= PuppetParts Sensor;
		PuppetParts::= ;


		MemberStart::= TOK_MEMBER ;
/.*/
		case $rule_number:{
			pushNode("member");
		}break;


/*./
		Member::= MemberStart TOK_LBRACE MemberParts TOK_RBRACE OptionalSemicolon;
/.*/
		case $rule_number:{
			popNode();
		}break;


/*./
		MemberParts::= MemberParts Var;
		MemberParts::= ;


		Var::= StringVar;
		Var::= IntVar;
		Var::= FloatVar;
		Var::= BoolVar;


		StringVar::=	TOK_IDENTIFIER TOK_ASSIGN TOK_STRINGCONSTANT OptionalSemicolon;
/.*/
		case $rule_number:{
			//debugRule("STRING",ruleno);
			registerVariable(symbol(0).value<QString>(),symbol(1));
		}break;


/*./
		IntVar::=	TOK_IDENTIFIER TOK_ASSIGN TOK_INTCONSTANT OptionalSemicolon;
/.*/
		case $rule_number:{
			//debugRule("INT",ruleno);
			registerVariable(symbol(0).value<QString>(),symbol(1));
		}break;


/*./
		FloatVar::=	TOK_IDENTIFIER TOK_ASSIGN TOK_FLOATCONSTANT OptionalSemicolon;
/.*/
		case $rule_number:{
			//debugRule("FLOAT",ruleno);
			registerVariable(symbol(0).value<QString>(),symbol(1));
		}break;


/*./
		BoolVar::=	TOK_IDENTIFIER TOK_ASSIGN TOK_BOOLCONSTANT OptionalSemicolon;
/.*/
		case $rule_number:{
			//debugRule("BOOL",ruleno);
			registerVariable(symbol(0).value<QString>(),symbol(1));
		}break;


/*./
		OptionalSemicolon::= TOK_SEMICOLON;
		OptionalSemicolon::= ; --OR NOT, both is ok (we cater to users with post C-lang developer syndrome (PCLDS))
/. */

	} // switch

}

// ./

