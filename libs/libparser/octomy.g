-- NOTE: Why don't we simplify the build by using merged_output option to form
--       one file instead of 4? Because this file becomes impossible to use,
--       since we cannot include it without causing duplicate symbols being
--       linked and we cannot link it without manually specifying a header for
--       it.

-- This gives a name to the table. Default is simply "parser"
-- Generates octomy_table.cpp & octomy_table_p.h
%parser octomy_table

-- This gives filenames to the parser itself
%decl octomy_parser.hpp
%impl octomy_parser.cpp


%token TOK_NUMBER

%token TOK_DESCRIPTOR
%token TOK_PLAN
%token TOK_PUPPET
%token TOK_HUB
%token TOK_REMOTE
%token TOK_AGENT
%token TOK_MEMBER
%token TOK_PUBKEY
%token TOK_KEY
%token TOK_PLUGIN
%token TOK_TRUE
%token TOK_FALSE
%token TOK_LPAREN
%token TOK_RPAREN
%token TOK_LBRACKET
%token TOK_RBRACKET
%token TOK_LBRACE
%token TOK_RBRACE
%token TOK_COLON
%token TOK_ASSIGN
%token TOK_STRING
%token TOK_IMPORT
%token TOK_IDENTIFIER
%start Plan

/:// WARNING:                                                             :WARNING
// WARNING: DO NOT EDIT THIS FILE! IT IS AUTOGENERATED BY QLALR         :WARNING
// WARNING:                                                             :WARNING

#ifndef OCTOMY_PARSER_HPP
#define OCTOMY_PARSER_HPP

#include "octomy_table_p.h"

#include <QString>
#include <QDebug>


struct yy_buffer_state;
typedef struct yy_buffer_state *YY_BUFFER_STATE;

class OctomyLexer{
	private:
		YY_BUFFER_STATE buf;
	public:

		bool init(const char *in);
		bool deinit();
		int nextToken();

};




class OctomyParser{
	private:

		inline int nextToken(){
			return lexer.nextToken();
		}

	private:

		OctomyLexer lexer;
		octomy_table table;
		int stack[10];
	public:
		OctomyParser(){
			qDebug()<<"PARSER CTOR";
			for(int i=0;i<10;++i){
				stack[i]=2;
			}
		}


		bool parse(QString s){
			qDebug()<<"GPARSER PARSE";
			bool status=lexer.init(s.toStdString().c_str());
			int t=0;
			do{
				t=nextToken();
				consumeRule(t);
			}while(t>0);
			status &=lexer.deinit();
			return status;

		}

		QString toString(){
			QString out="";
			for (int r = 0; r < octomy_table::RULE_COUNT; ++r) {
				int ridx = octomy_table::rule_index [r];
				int rhs = octomy_table::rhs [r];
				out += QString::number(r + 1) +" "+ QString(octomy_table::spell[octomy_table::rule_info [ridx]])+":\n";
				++ridx;
				for (int i = ridx; i < ridx + rhs; ++i)
				{
					int symbol = octomy_table::rule_info [i];
					if (const char *name = octomy_table::spell [symbol]){
						out+="\tname="+QString(name);
					}
					else{
						out+="\tsymbol="+QString(symbol);
					}
					out+="\n";
				}
			}
			return out;
		}

		void consumeRule(int rule);

		int &sym(int index){
			qDebug()<<"PARSER SYM";
			if(index<1){
				index=1;
			}
			else if(index>10){
				index=10;
			}
			return stack[index-1];
		}
};


#endif // OCTOMY_PARSER_HPP
:/


/.// WARNING:                                                             :WARNING
// WARNING: DO NOT EDIT THIS FILE! IT IS AUTOGENERATED BY QLALR         :WARNING
// WARNING:                                                             :WARNING


#include "octomy_parser.hpp"
#include "octomy_lexer.h"

#include <QDebug>
#include <cstdlib>

////////////////////////////////////////////////////////////////////////////

bool OctomyLexer::init(const char *in){
	qDebug()<<"INITIALIZING LEXER";
	buf=yy_scan_string(in);
	return 0!=buf;
}

bool OctomyLexer::deinit(){
	qDebug()<<"DEINITIALIZING LEXER";
	buf=0;
	return true;
}

////////////////////////////////////////////////////////////////////////////

void OctomyParser::consumeRule(int ruleno){
	qDebug()<<"CONSUMING RULE: "<<ruleno;

	switch (ruleno) {
		./
Plan::= TOK_PLAN TOK_LBRACE PlanParts TOK_RBRACE;
		/.
		case $rule_number:
			qDebug() << "Plan:" << sym(1) << sym(2) << sym(3);
			break;
			./

PlanParts::= PlanParts Puppet;
PlanParts::= ;

Puppet::= TOK_PUPPET TOK_LBRACE PuppetParts TOK_RBRACE;

PuppetParts::= PuppetParts Member;
PuppetParts::= ;

Member::= TOK_MEMBER TOK_LBRACE MemberParts TOK_RBRACE;

MemberParts::= MemberParts Var;
MemberParts::= ;

Var::= TOK_IDENTIFIER TOK_ASSIGN TOK_STRING;
Var::= TOK_IDENTIFIER TOK_ASSIGN TOK_NUMBER;
Var::= TOK_IDENTIFIER TOK_ASSIGN Bool;

Bool::= TOK_TRUE;
Bool::= TOK_FALSE;



			/.

	} // switch

}


./


